/*
 * Title:        GridSim Toolkit
 * Description:  GridSim (Grid Simulation) Toolkit for Modeling and Simulation
 *               of Parallel and Distributed Systems such as Clusters and Grids
 * License:      GPL - http://www.gnu.org/copyleft/gpl.html
 *
 * Copyright (c) 2006, The University of Melbourne, Australia
 */
package gridsim.auction;

import eduni.simjava.Sim_event;
import eduni.simjava.Sim_port;
import eduni.simjava.Sim_system;
import gridsim.GridSim;
import gridsim.GridSimTags;
import gridsim.IO_data;

/**
 * This class is used by entities that want to participate
 * as bidders in auctions.
 * <p>
 * To use this class, you need to redirect the events that
 * the entity cannot treat. You need to call 
 * {@link #processEvent(Sim_event)} passing the event that
 * the entity is not able to process. If the event is related
 * to the auctions (ie. has a tag code corresponding to an auction event)
 * the observer is able to process it by passing the message
 * to its Responder.
 *
 * @author       Marcos Dias de Assuncao
 * @since        GridSim Toolkit 4.0
 * @see gridsim.auction.Responder
 */
public class AuctionObserver extends GridSim {
	private Responder responder;
	private int bidderID;
	private Object syncSteps = new Object();
	
    /** The Bidder output port. This port is mainly used to send
     * messages generated by this AuctionObserver class.
     * This is because an AuctionObserver class doesn't have networked
     * entities (Input and Output).
     */
    protected Sim_port outputPort;
	
	/**
	 * Constructor
	 * @param bidderID the bidder if, since it sends messages on the bidder's behalf 
	 * @param entityName a name for this entity
	 * @param port the port to be used as output of messages
	 * @throws Exception
	 */
	public AuctionObserver(int bidderID, String entityName, Sim_port port) throws Exception {
		super(bidderID + "_" + entityName);
		this.bidderID = bidderID;
		this.outputPort = port;
	}
	
	/**
	 * Constructor
	 * @param bidderID the bidder if, since it sends messages on the bidder's behalf
	 * @param entityName entityName a name for this entity
	 * @param responder the responder which will deal with the messages 
	 * 			that this responder receives
	 * @param port the port to be used as output of messages
	 * @throws Exception
	 */
	public AuctionObserver(int bidderID, String entityName, Sim_port port,
			Responder responder) throws Exception {
		this(bidderID, entityName, port);
		this.responder = responder;
	}
	
	/**
	 * Sets a responder to this observer 
	 * @param responder the responder
	 * @pre responder != null
	 * @return <tt>true</tt> if the responder was correctly set
	 */
	public boolean setResponder(Responder responder){
		if(responder == null)
			return false;
		
		this.responder = responder;
		return true;
	}
	
	/**
	 * Returns the responder that the observer is using
	 * @return the responder
	 */
	public Responder getResponder(){
		return responder;
	}
	
	/**
	 * 
	 */
	public void body(){
		// Process events until END_OF_SIMULATION is received from the
        // GridSimShutdown Entity
		
        Sim_event ev = new Sim_event();
        while ( Sim_system.running() )
        {
            super.sim_get_next(ev);

            // if the simulation finishes then exit the loop
            if (ev.get_tag() == GridSimTags.END_OF_SIMULATION){
                break;
            }

            // process the received event
            processEvent(ev);
        }

        // remove I/O entities created during construction of this entity
        super.terminateIOEntities();
		
	}
	
	
	/**
	 * Process an event.
	 * @param ev
	 * @return <tt>true</tt> if the event was treated; <tt>false</tt> otherwise.
	 */
	public boolean processEvent(Sim_event ev){
       int src_id = -1;
       Message msg = null;
       Message respMsg = null;
            
       if (responder == null){
       		System.out.println("No responder to deal with auction messages!");
            return false;
       }
           
       switch ( ev.get_tag() ){
       		case AuctionTags.AUCTION_INFORM_START:
               	msg = (Message)ev.get_data();
               	src_id = msg.getSourceID();
               	synchronized(syncSteps){
               		respMsg = responder.onReceiveStartAuction((MessageInformStart)msg);
               	}
           	break;
            	
            case AuctionTags.AUCTION_CFP:
               	msg = (Message)ev.get_data();
               	src_id = msg.getSourceID();
               	synchronized(syncSteps){
               		respMsg = responder.onReceiveCfb((MessageCallForBids)msg);
               	}
            break;
            	
            case AuctionTags.AUCTION_INFORM_OUTCOME:
               	msg = (Message)ev.get_data();
              	src_id = msg.getSourceID();
              	synchronized(syncSteps){
              		respMsg = responder.onReceiveInformOutcome((MessageInformOutcome)msg);
              	}
            break;

            case AuctionTags.AUCTION_REJECT_PROPOSAL:
               	msg = (Message)ev.get_data();
               	src_id = msg.getSourceID();
               	synchronized(syncSteps){
               		respMsg = responder.onReceiveRejectProposal((MessageRejectBid)msg);
               	}
            break;
            	
            // other unknown tags are processed by this method
            default:
            	return false;
       }
            
       if(respMsg!=null){
       		respMsg.setDestinationID(src_id);
        		
       		int tag = - 1;
       		if(respMsg instanceof MessageBid){
        		tag = AuctionTags.AUCTION_PROPOSE;
        		((MessageBid)respMsg).setBidder(this.bidderID);
        	}
        	else if(respMsg instanceof MessageRejectCallForBid){
        		tag = AuctionTags.AUCTION_REJECT_CALL_FOR_BID;
        		((MessageRejectCallForBid)respMsg).setBidder(this.bidderID);
        	}
        	
        	double scheduleAt = (respMsg.getScheduleTime() > 0.0) ? 
        			respMsg.getScheduleTime() : GridSimTags.SCHEDULE_NOW;  
        	
        	super.sim_schedule(this.outputPort, scheduleAt,
        			tag, new IO_data(respMsg, 100, src_id));
       }
       return true;
	}
}
