package gridsim.fta;

import eduni.simjava.Sim_event;
import eduni.simjava.Sim_system;
import gridsim.GridSim;
import gridsim.GridSimTags;
import gridsim.parallel.log.LoggerEnum;
import gridsim.parallel.log.Logging;

import java.util.Hashtable;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * This class extends the {@link GridSim} class to generate the failure list.
 *  
 * @param 	name is the name of the entity
 * @param	resourceName is the name of the resource
 * @param	FailureModel is the list of events which is created by {@link FailureFileReader}
 * 
 *  
 * @author       Bahman Javadi
 * @since        GridSim Toolkit 5.0
 * 
 * @see 	FailureFileReader
 */

public class FailureGenerator extends GridSim{
	private static Logger logger = Logging.getLogger(LoggerEnum.PARALLEL);
    
	private FailureModel model = null;	// failure model from the FTA file
    private int resID;         		// resource ID


    public FailureGenerator(String name, String resourceName, FailureModel model) throws Exception {
    	super(name);

    	this.resID = GridSim.getEntityId(resourceName);
    	this.model = model;
}

    /**
     * Generates failures according to provided model when the simulation starts.
     */
    public void body() {
    	logger.log(Level.INFO, super.get_name() + " is starting...");
        
        boolean success = sendFailures();
        
        if(success) {
        	
            Sim_event ev = new Sim_event();
        	while (Sim_system.running()) {
                super.sim_get_next(ev);

                // if the simulation finishes then exit the loop
                if (ev.get_tag() == GridSimTags.END_OF_SIMULATION) {
                    break;
                }
              
            }
        }
        else {
        	logger.log(Level.SEVERE, super.get_name() + " was unable to send the failures.");
        }

        // shut down all the entities, including GridStatistics entity since
        // we used it to record certain events.
        shutdownGridStatisticsEntity();
        shutdownUserEntity();
        terminateIOEntities();

        logger.log(Level.INFO, super.get_name() + " is exiting...");
    }
    
    /**
     * sends the failures generated by the model to the resource 
     * @return <code>true</code> if successful; <code>false</code> otherwise.
     */
    private boolean sendFailures() {
    	int event_type;
    	int i,k;
    	int avg_event = 0;
    	
    	logger.log(Level.INFO, super.get_name() +  " is sending failures to " + 
    			GridSim.getEntityName(resID) + " ...");

    	List<FailureEvent> events = model.generateFailure();
    	
    	if(events == null) {
    		return false;
    	}
    	
    	// map the node IDs to the range of 0...#nodes
    	Hashtable<Integer, Integer> ids = new Hashtable<Integer, Integer>();
    	k = 0;
    	for (FailureEvent ev : events){
        	int id = ev.getNodeID();	// node id

        	ids.put(id, new Integer(k));
        	k++;
        	
        	int numEvents = ev.getnumEvent();	// number of events
        	avg_event += numEvents;
//       		logger.log(Level.INFO, "Node: " + id + " has " + ev.getnumEvent()+ " events.");

        	for (i=0; i<numEvents; i++){
        		event_type = ev.geteventType(i);	// get event type
        		// send the resource failure event
        		if (event_type==0){
        			super.send(resID, ev.getstartTime(i),GridSimTags.GRIDRESOURCE_FAILURE, ids.get(id));
        		}
        		// send the resource recovery event
        		if (event_type==1){
        			super.send(resID, ev.getstartTime(i),GridSimTags.GRIDRESOURCE_RECOVERY, ids.get(id));
        		}
        	}	
      }
		logger.log(Level.INFO, "Average Event per Node:" + avg_event/k);
    	return true;
    }

}
